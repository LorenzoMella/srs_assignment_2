	---
title: "Statistical Research Skills -- Assignment 2"
author: "Lorenzo Mella (UUN: s1566023)"
output: pdf_document
---


```{r}
library(tidyverse, quietly = TRUE)
library(patchwork, quietly = TRUE)
library(mixtools)
library(pracma)
```

# Introduction

## Kernel density estimator

Problematic choices:

- bandwidth
- kernel shape


## Histogram estimator

Problematic choices:

- number of bins

## Mixture model estimator

Problematic parameter:

- conditional distributions
- number of conditional distributions


# Experimental setting

## Densities that represent a wide testing range of possibilities

```{r}
# Define densities and RNGs for the distributions to be tested

# Normal (unimodal base case)
ddistrib_1 = function(x) dnorm(x, 5, 2)
rdistrib_1 = function(n) rnorm(n, 5, 2)
# Student t (unimodal with heavier tails)
ddistrib_2 = function(x) dt(x / 3, df = 1)
rdistrib_2 = function(n) 3 * rt(n, df = 1)
# Uniform (discontinuous density with a dense modes)
ddistrib_3 = function(x) dunif(x, 3, 8)
rdistrib_3 = function(n) runif(n, 3, 8)
# Gamma (unimodal, positively skewed)
ddistrib_4 = function(x) dgamma(x, 3, 1)
rdistrib_4 = function(n) rgamma(n, 3, 1)
# Mixture of distributions
# (trimodal, with many challenging features)
ddistrib_5 = function(x) {
  0.5 * dexp(x, 0.7) + 0.3 * dgamma(9 - x, 2, 1.5) + 0.2 * dunif(x, 3.5, 5)
}
rdistrib_5 = function(n) {
  num_samples = rmultinom(1, n, c(0.5, 0.3, 0.2))
  sample(c(rexp(num_samples[1], 0.7),
           9 - rgamma(num_samples[2], 2, 1.5),
           runif(num_samples[3], 3.5, 5)))
}
```

## One shot experiments

- Graphs
- Discussion

```{r density_reconstruction}
# A density function obtained from histogram data returned by hist

hist_density = function(hist_output, x) {
  # Find the bin where x lies: its index is the maximum number
  # of breaks less or equal to x. Return the histogram normalised
  # frequency of that bin
  sapply(x, FUN = function(y) {
    if (y < hist_output$breaks[1] |
          y >= hist_output$breaks[length(hist_output$breaks)]) {
      return(0)
    } else {
      return(hist_output$density[sum(hist_output$breaks - y <= 0)])
    }
  })
}

# A density function obtained by linear interpolation
kern_density = function(density_output, x) {
  approxfun(density_output$x, density_output$y, yleft = 0, yright = 0)(x)
}

# A density function obtained from the output of normalmixEM
normalmix_density = function(mix_output, x) {
  sapply(x, function(y) sum(mix_output$lambda * dnorm(y, mix_output$mu, mix_output$sigma)))
}

```

```{r cross_validation}
# Compute the ISE Monte Carlo estimate (for unknown original density)
cv_error = function(density_est, data) {
  # Compute the integral of the estimator
  int_fh2 = integrate(density_est, lower = -Inf, upper = Inf)
  # Monte-carlo estimate of the cross term
  int_ffh = mean(density_est(data))
  return(int_fh2$value - 2 * int_ffh)
}

samples_1 = rdistrib_1(250)

max_breaks = 10:50
hist_densities = lapply(max_breaks,
                        function(B) {
                          function(x) hist_density(hist(samples_1, breaks = B, plot = FALSE), x)
                        })

bws = seq(0.1, 2, by = 0.1)
kde_densities = lapply(bws,
                       function(B) {
                         function(x) kern_density(density(samples_1, bw = B), x)
                       })


cv_errors = as.numeric(lapply(kde_densities,
                              function (H) cv_error(H, samples_1)))

```


```{r graph_functions}
# Composable plots for histograms and KDEs

overlay_hist_plot = function(data, fun, hist_breaks, distr_name) {
  ggplot(data = tibble(xx = data), aes(x = xx)) +
    geom_histogram(aes(y = ..density..), breaks = hist_breaks,
                   color = "red", fill = "red", lwd = 1.2, alpha = 0.3, xlim = c(0,10)) +
  stat_function(fun = fun, color = "black", lwd = 1, xlim = c(0, 10)) +
    ggtitle(distr_name)
}

overlay_dens_plot = function(data, fun, dens_ker, dens_bw, distr_name) {
  ggplot(data = tibble(xx = data), aes(x = xx)) +
    stat_density(data = tibble(xx = data), aes(x = xx),
                 kernel = dens_ker, bw = dens_bw,
                 color = "blue", fill = "blue", alpha = 0, lwd = 1.5) +
    stat_function(fun = fun, color = "black", lwd = 1, xlim = c(0, 10)) +
  ggtitle(distr_name)
}
```

```{r graphing}

# Prepare the distribution samplers, samples and density functions
max_samples = 250
rdistribs = list(rdistrib_1, rdistrib_3, rdistrib_4, rdistrib_5)
x_samples = lapply(rdistribs, function(fun) fun(max_samples))
ddistribs = list(ddistrib_1, ddistrib_3, ddistrib_4, ddistrib_5)
dnames = c("Normal", "Uniform", "Gamma", "Mixture")


# Histogram plot
grph = overlay_hist_plot(x_samples[[1]], fun = ddistribs[[1]],
                         hist_breaks = hist(x_samples[[1]],
                                            breaks = "FD",
                                            plot = FALSE)$breaks,
                         dnames[1])
for (i in 2:4) {
  grph = grph + overlay_hist_plot(x_samples[[i]], fun = ddistribs[[i]],
                                  hist_breaks = hist(x_samples[[i]],
                                                     breaks = "FD",
                                                     plot = FALSE)$breaks,
                                  dnames[i])
}
grph + plot_layout(nrow = 1, widths = 0.5)
ggsave("distrib_hist.pdf", device = "pdf")


# Histogram plot with custom bins
max_bins = 60
grph = overlay_hist_plot(x_samples[[1]], fun = ddistribs[[1]],
                         hist_breaks = seq(0, 10, length.out = max_bins),
                         dnames[1])
for (i in 2:4) {
  grph = grph + overlay_hist_plot(x_samples[[i]], fun = ddistribs[[i]],
                                  hist_breaks = seq(0, 10, length.out = max_bins),
                                  dnames[i])
}
grph + plot_layout(nrow = 1, widths = 0.5)
ggsave(sprintf("distrib_hist_%d.pdf", max_bins), device = "pdf")


# Rectangular kernel plot
dens_bw_rect = 2
grph = overlay_dens_plot(x_samples[[1]], fun = ddistribs[[1]],
                         dens_ker = "rectangular",
                         dens_bw = dens_bw_rect,
                         dnames[1])
for (i in 2:4) {
  grph = grph + overlay_dens_plot(x_samples[[i]], fun = ddistribs[[i]],
                                  dens_ker = "rectangular",
                                  dens_bw = dens_bw_rect,
                                  dnames[i])
}
grph + plot_layout(nrow = 1, widths = 0.5)
ggsave("distrib_kde_rect.pdf", device = "pdf")


# Gaussian kernel plot
dens_bw_gauss = 2
grph = overlay_dens_plot(x_samples[[1]], fun = ddistribs[[1]],
                         dens_ker = "gaussian",
                         dens_bw = dens_bw_gauss, dnames[1])
for (i in 2:4) {
  grph = grph + overlay_dens_plot(x_samples[[i]], fun = ddistribs[[i]],
                                  dens_ker = "gaussian",
                                  dens_bw = dens_bw_gauss, dnames[i])
}
grph + plot_layout(nrow = 1, widths = 0.5)
ggsave("distrib_kde_gauss.pdf", device = "pdf")


# Epanechnikov kernel plot
dens_bw_epanech = "nrd0"
grph = overlay_dens_plot(x_samples[[1]], fun = ddistribs[[1]],
                         dens_ker = "epanechnikov",
                         dens_bw = dens_bw_epanech,
                         dnames[1])
for (i in 2:4) {
  grph = grph + overlay_dens_plot(x_samples[[i]], fun = ddistribs[[i]],
                                  dens_ker = "epanechnikov",
                                  dens_bw = dens_bw_epanech,
                                  dnames[i])
}
grph + plot_layout(nrow = 1, widths = 0.5)
ggsave("distrib_kde_epanech.pdf", device = "pdf")

```


```{r ISE_hist_bins}
max_samples = 1000

# With histogram density estimation

theoretical_ISE = function(dens_fun, estimator_fun, range = c(-Inf, Inf), subdiv = 400) {
  integrate(function(x) {(estimator_fun(x) - dens_fun(x))^2},
            lower = range[1],
            upper = range[2],
            subdivisions = subdiv)$value
}

# Compute histograms of the same sample
x_sample = x_samples[[2]]
ddistrib = ddistribs[[2]]

hist_outputs = lapply(seq(5, 40, by = 1),
                      function(B) hist(x_sample,
                                       breaks = seq(min(x_sample),
                                                    max(x_sample),
                                                    length.out = B),
                                       plot = FALSE))

ISEs = numeric(length(hist_outputs))
for (i in 1:length(ISEs)) {
  estim = function(x) hist_density(hist_outputs[[i]], x)
  ISEs[i] = theoretical_ISE(ddistrib, estim)
}

plot(ISEs, lwd = 2, type = "l")
```


```{r ISE_kde_bw}
max_samples = 250

# With kde density estimation

# We redefine the integration function with the pracma package
theoretical_ISE_pracma = function(dens_fun, estimator_fun, range = c(-10, 10)) {
  quad(function(x) {(estimator_fun(x) - dens_fun(x))^2},
            xa = range[1],
            xb = range[2])
}

# Compute KDEs of the same sample
x_sample = x_samples[[2]]
ddistrib = ddistribs[[2]]

kde_outputs = lapply(seq(0.01, 2, by = 0.02),
                     function(BW) density(x_sample, bw = BW, kernel = "gaussian"))

ISEs = numeric(length(kde_outputs))
for (i in 1:length(ISEs)) {
  estim = function(x) kern_density(kde_outputs[[i]], x)
  ISEs[i] = theoretical_ISE_pracma(ddistrib, estim)
}

plot(ISEs, lwd = 2, type = "l")


# With kernel density estimation
integrate(function(x) {(kern_density(density_output = density(samples_1), x) - ddistrib_1(x))^2}, lower = -Inf, upper = Inf)

curve((kern_density(density_output = density(samples_1), x) - ddistrib_1(x)), from = -10, to = 10, n = 1000, ylim =c(0, .5))
plot_x = seq(from = -10, to = 10, length.out = 1000)
lines(plot_x, kern_density(density_output = density(samples_1), plot_x), col = "red")
lines(plot_x, ddistrib_1(plot_x), col = "blue")


# With mixture density estimation (unused)
integrate(function(x) {(normalmix_density(mix_output = normalmixEM(samples_1), x) - ddistrib_1(x))^2},
          lower = -Inf, upper = Inf)

curve((normalmix_density(mix_output = normalmixEM(samples_3), x) - ddistrib_1(x)), from = -10, to = 10, n = 1000)
plot_x = seq(from = -10, to = 10, length.out = 1000)
lines(plot_x, normalmix_density(mix_output = normalmixEM(samples_3), plot_x), col = "red")
lines(plot_x, ddistrib_3(plot_x), col = "blue")

```

## Monte Carlo simulation

- ISEs for sample sizes 250, 500, 1000

```{r}
# TBD
```


Two things can be done here:

* Compute a Monte Carlo estimate of the MISE (per method per sample size)
* Plot ISE histograms for each category and as a function of "time" on the same graph

- Discussion
